\documentclass[a4paper,10pt]{report}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{a4}
\usepackage{algorithm}
\usepackage{tikz}
\usetikzlibrary{arrows}



\begin{document}
\title {The Engine Behind Model Checking}
\author{Reema S Patne (604163)\\
  MSc.Computing and Software Technology Swansea University}
  \maketitle

\begin{abstract}
  In order to ensure the safety and quality of a system, it is necessary to undergo a process of system validation which checks the correctness of specifications, designs and products \cite{Wang2007}. We find post-completion errors which are a particular kind of error in interactive systems. When there is an incorrect sequencing of goals and sub-goals, this type of error occurs \cite{Hoare1986}. Mainly because, the primary goal is achieved before all of the prerequisite sub-goals have been satisfied. This project shows how we can check for this property in a formal model of an interactive system. Of all the validation techniques, model checking has become the most popular approach in the both hardware and software areas due to the availability of various support tools and its success in the project \cite{Palshikar2004}. This project is to get a working understanding of a model checking tool that uses SAT solvers. Specifically, suggesting the lightweight formal methods, such as the Alloy structural modelling language, is particularly well suited for this task. As a case study we develop an example interactive system using ubiquitous coffee machine where both coffee and change must be delivered.However, this is to be expected as part of learning to use a new system.
\end{abstract}

\begin{center}
\title \textbf{Declaration}
\end{center}
This work has not previously been accepted in substance for any degree and is not being concurrently submitted in candidature for any degree.

This dissertation is the result of my own independent work/investigation, except where otherwise stated. Other sources are acknowledged by giving explicit references. A bibliography is appended.

I hereby give consent for my dissertation, if accepted, to be available for photocopying and for inter-library loan, and for the title and summary to be made available to outside organisations.

\begin{flushleft}Signed ..................\end{flushleft} 
\begin{flushright}Date....................\end{flushright}                                                                                                                                               \clearpage
\begin{center}
\title {Acknowledgement}
\end{center}
My foremost thank goes to my thesis supervisor Dr. Oliver Kullmann. Without him, this dissertation would not have been possible. I thank him for his patience and encouragement that carried me on through difficult times, and for his insights and suggestions that helped to shape my research skills. His valuable feedback contributed greatly to this dissertation.

I thank all the students and staffs in the Computer Science department, who taught me knowledge and helped me with my study and life in Swansea University. Especially I thank several good friends of mine, who always encouraged and supported me.

 Last but not least, I thank the Almighty, my parents and all other family members for always being there when I needed them most, and for supporting me throughout the years.
\begin{flushright}
Reema S Patne\\
604163\\
MSc in Computing And Software Technology\\
Swansea University\\
September 2012.
\end{flushright}
 
\tableofcontents

\chapter{Introduction}
\label{Intro}

Interactive systems are prone to the common types of errors like the one similar to the specific behaviour of cash machine who leaves back their cash card in the ATM machine after the cash is withdrawn. Also, like the ones retrieving the photocopies from the Xerox but forgetting to collect the original document is another common error with the interactive systems. This type of error is referred to as a``Post Completion" error \cite{Boyatt}. Achieving the primary goal even before all the sub-goals are satisfied is the key characteristics of these errors. In other words, the main objective is achieved but, due to the wrong sequencing of events we forget to do the items that were before it on the list. These kinds of errors usually don't occur, but however we should try the every possible way of preventing these kinds of errors from occurring. This kind of errors can be handled by ensuring that sequences of sub-tasks are completed before the main goal is achieved at the end of the sequence. The various interactive errors can be checked by correctly formulating the problem and using the existing formal method tools \cite{P.Curson}. This error can be approached by using the lightweight formal method, namely Alloy which uses the SAT solvers, where the constraints in the Alloy -a declarative modelling language, can be translated into Boolean logic and solved with the SAT-solver \cite{Yeung2005}. But the project focuses on the SAT translation and not on the  SAT solver which is a black box for the project. The presented approach is explained with help of an example coffee machine. This project demonstrates how the Alloy Analyser which is used as a SAT translation to conduct fully automated analysis of a coffee machine specification represented in Alloy. 

The Alloy Analyzer is a compiler which translates the problem to be analyzed into a (usually huge) Boolean formula. This formula is then handed to a SAT solver, and the solution is translated back by the Alloy Analyzer into the language of the model. The Alloy Analyser thus makes the problem finite (and reducible to a Boolean formula) by solving the problems within a user-specified scope that bounds the size of the domains. In otherwords, model-finder essentially translates a model expressed in relational logic into a corresponding Boolean logic formula, and then invoke an off-the-shelf SAT-solver on the Boolean formula. In the event that the solver finds a solution, the result is translated back into a corresponding binding of constants to variables in the relational logic model. Although the analysis can be performed by a traditional formal method, there is a lower barrier to entry afforded by lightweight formal methods.

The lightweight formal methods such as Alloy provide the user with many benefits:
\begin{itemize}
\item {In order to develop an ongoing development, the formal basis provides an automatic feedback in a more focused way.}
\item {Tools provide a more ``programmer-friendly" interface and can be used by any developers who are not formal methods experts} \cite{Boyatt}.
\item {In software engineering, one of the great benefits of Alloy is that you can analyze a tiny model, write three lines, and analyze it, add few more lines and analyze again \cite{ErichGamma1995}. This increment makes Alloy especially good for exploring design ideas. }
\end{itemize}
These approaches are used much earlier in the development process to validate aspects of an evolving specification and to explore requirements \cite{Hoare1986}. Here the focus is on post-completion errors as an example property but is chosen only to serve as an example and our models are not designed solely for any particular property \cite{ErichGamma1995}. The models are general and able to be used to investigate many other properties.
 
\section{Outline Of This Dissertation}
\label{Outline dissert}

This report mainly consists of Four parts. Chapter I is the Introduction including the outline of the project.

In Chapter II the concept of systems and their specifications and the basic theory of model checking technique will be presented as a part of Literature Survey. A simple example to illustrate the technique is mentioned. The various model checkers along with their uses are listed. The new challenges faced throughout the project are also mentioned along with the conclusion of the literature survey.

Chapter II examines an Alloy model which solves the coffee machine problem, using the module for modelling the ordered state. It will conclude with the method, result and refinement along with the references. As a part of case study an Alloy Analyser example is also presented.

Finally in Chapter III the discussion of theoretical survey of background to a project is considered. The approach which is used to make the specification executable will be discussed. It introduces the declarative modelling language namely Alloy followed by development and analysis of a Alloy model which includes alloy interface walkthrough also introducing the Alloy's improved solution visualizer. It also includes the schedule of the project planned throughout the course.

\chapter{Model Checking}
\label{Model check}

The technique used for validating a system is Model checking. The design process and the validation process are the must to ensure the correctness of specifications, designs and products of the system \cite{ErichGamma1995}. Validation is done to see that whether the system meets all its requirements. 

Model checking systematically checks the validity of a given finite-state model of a system and properties stated in the form of logical formalism such as temporal logic \cite{Palshikar2004}. It uses algorithms which are executed by the computer tools \cite{McMillan2003}. The inputs to such model checkers are the description of the model and the description of the properties. Once these files are fed as an input, the model checker performs the verification. If error occurs, then the model checker provides the counter-example to explain under which circumstances the error can be generated. This counter-example helps in finding the error and repairing the specifications of the model \cite{Wang2007}. This can be shown with help of the following diagram. It shows us how the verification process takes place in the model checking \cite{DanielJackson}.  

Describing what a system is required to do is known as system \cite{Wang2007}. By doing so, we will be able to understand the system. Various validation techniques are used to check the correctness of specification. It guarantees the quality of the system and also its safety \cite{Clarke1999}. Model checking is one of the most popular validation techniques. For a system defined in finite state model and a property defined in terms of logical formalism, model checking techniques could systematically check the validity of this property \cite{Engler}. A finite-state model is used to design computer programs and digital logic circuits \cite{ErichGamma1995}. It is as an abstract machine that can be in one of a finite number of states \cite{M.Davis1962}. It will be only in one state at a time; the state it is in at any given time is called the current state. When initiated by a triggering event or condition, the state changes, this is called a transition \cite{D.Jackson}.

Roughly, M is an abstract model of a system whose structure is defined as finite-automata and $\phi$  is a logical formula specifying a desirable property such that M satisfies $\phi$  abbreviated as $M \models \phi$. 

Model checking helps from preventing the bugs even before penning down the code of the project i.e., during the requirement and the design phase itself \cite{ErichGamma1995}. It prevents the further breed of the bugs and hence it makes sense by being cost effective \cite{Havelund}. The errors which are not been able to find by simulation is done by model checking by considering all possible behaviours of the system \cite{Havelund}. 

Model checking is the one of the foremost applications of logics which ranges from computer science to computer engineering. Since then, there has been a multiple breakthrough. The gap which was built between the theoretical computer science, hardware and software engineering was bridged by Model Checking. Now, model checking has been extensively used for verifying many Software and also used in hardware industry. It has virtually became a universal tool for the analysis of the systems. Henceforth, this project will focus on the state of the art of model of model checking.

\section{Systems and their Specifications}
\label{Sys and Spec}

Describing a system is called specification. Specification helps in finding errors and understanding a system \cite{Wang2007}. So, it is a good practise to have a clear idea about the design and improve it before the implementation \cite{ErichGamma1995}. The specification of the system can be functional or non-functional i.e. what a system is supposed to do or performance properties \cite{Wang2007}. These specifications are written in formal language with proper syntax and semantics which can be verified and validated with respect to requirements \cite{D.Jackson}.

It helps in developing the explicit model of a system which is clear, precise and unambiguous. Mathematics is used as a basic tool to achieve this. Here, reading the accompanying words in order to understand the relation between the equations is a bit tedious. In order to overcome this shortcoming using mathematics as a basic tool, logicians have temporal logic which is precise and completely formal mathematics. This temporal logic is used in such a way so as to describe the system behaviour. 

\section{Temporal Logic} 
\label{Temp Logic}

There are various interpretations of temporal logic depends on the individual as how to consider the system with time \cite{Berard}. It is the logic for expressing mathematics. It supports formulating the properties of the system behaviour with respect to time \cite{Berard}. There are various types of temporal logics:
\begin{itemize}
\item Temporal Logics used to specify the reactive systems are:

\textbf{Linear temporal logic:}It allows the statement of properties of execution sequences of a system.

 \textbf{Branching temporal logic:}It allows the user to write formulas which include some sensitivity to the choices available to a system during its execution.
\end{itemize}
 These two kinds of temporal logic are characterized by a continuous interaction with the environment \cite{Engler}.
\begin{itemize}
\item Temporal Logics used to specify the time-critical systems:

 \textbf{Real-Time temporal logic:}  It allows statement of properties of multiple concurrent processes and supports relative time references.
\end{itemize}

It is characterized by quantitative timing properties relating occurrences of events \cite{Engler}.
In order to avoid the errors we write specifications. Validation techniques are used to checking the correctness of the system \cite{Wang2007}.  

\section{Model-Checking Algorithm}
\label{Model chec Algo}

Model checking uses exhaustive state space search of the system model as algorithm: The desired properties satisfied for each state of the model \cite{Berard}. Reachability property is used to check whether the system can reach a state without any deadlocks. Reachability is considered as one of the important property which uses Reachability analysis technique \cite{M.Davis1962}. It starts from initial system state and see to it that it reaches all the possible system states which can be reached. For instance, in a traffic signal model, yellow, red and green are the three states. Model checking proves if it can reach some state, all the states are eventually got by the model, or if the model could never get some state \cite{M.Davis1962}.

\section{Approaches Of Model Checking}
\label{Appr to model check}

\begin{itemize}
\item Logic based approach: Here the system is modelled as finite-state automaton representing the states as values of variables and control location, and changes of a system from one state to other state is represented by transition \cite{DanielJackson}. If a system satisfying the desired behaviour given in some logic with the initial set of states, then the system is said to be correct \cite{DanielJackson}.
\item Behaviour based approach: Given the desired and the possible behaviour with the same notation, the equivalence relations are used as criteria for the correctness \cite{DanielJackson}. Hence, if the desired and the possible state behaviour are equivalent then the system is said to be correct \cite{DanielJackson}.  
\end{itemize}

\section{Model Checkers}

In verifying a system, model checking techniques uses tools known as model checkers. Due to the progress of model checking, industries are developing their own model checkers. 
Exhaustible list of  Model Checkers are given below:
\begin{description}
\item[Blast model checker:]Berkeley Lazy Abstraction Software Verification Tool abbreviated as BLAST. It is a model checking tool used for C programs.
\item[CADP:]Commonly known as  Construction and Analysis of Distributed Processes. It uses the formal description technique and software tools for simulation to facilitate the design of reliable systems.
\item Chess model Checker:It is a software which uses thread schedules to find bugs or errors in multi-threaded software such as deadlocks,data-corruption which are hard to find using testing tools. It helps in debugging the process by providing the full repeatable execution of the program which is causing an error.
\item[CHIC:] Commonly known as Checker for Interface Compatibility. It is used in hardware and software systems to verify the behavioural compatibility.
\item[FDR:] Commonly called as Failures-Divergences Refinement is the software tool used to check  the refinement.
\item[ISP:] Commonly known as In-situ Partial Order. It is a formal verification tool. They perform the verification at the level of code. It has successfully verified the codes for deadlocks and assertion violations.
\item[Java pathfinder:]The executable Java byte-code programs are verified by this Java pathfinder system. It does the model checking for the concurrent programs. As using this it helps in detecting the deadlocks and data races. It can also be used to model check the distributed applications and user interfaces.
\item[LTSA:] It is commonly known as Labelled Transition System Analyser. It is used to verify the concurrent systems. FPS process algebra is used to describe LTSA. The systems are finite state machines.
\item[MRMC:] Commonly known as Markov Reward Model Checker is tool written in C programming language. It model checks for discrete-time models and continuous time model. Within a given time and within the constraint it checks the reachability of the set of goal states.
\item[mCRL2 Toolset:]It is used to describe the concurrent systems since it uses the specification language.
\item[MoonWalker:]It model checks for .Net applications by detecting the errors. Also it is able to find the deadlocks and assertion violations as well.
\item[NuSMV:] It is the expansion of  symbolic model checker. It provides verification for industrial designs.Also it provides analysis of specifications \cite{McMillan1992}.
\item[Ompca:]It is commonly known as Open MP C Analyser. It helps in model checking  real-time systems with dense-time models. It is an application for timed automata’s.
\item[PAT:]It is commonly known as process analysis tool kit. It helps concurrent and real-time systems in reasoning and simulating. It helps in solving deadlocks and reachability.
\item[PRISM:]It is commonly called as probabilistic model checker. It is used in model checking for the system that exhibits probabilistic behaviour.This software tool is used in modelling and analysis of the system.
\item[Rabbit:]It does model checking by providing the reachability analysis and refinement. It is used for real-time systems.
\item[REDLIB:] It is a model checker for timed automata’s. It helps in verification tasks.
\item[SMART:] It is a model checker used to check the reliability and timing.
\item Spin Model Checker:It verifies the correctness of the models in automated fashion. This is one of the biggest achievements. It avoids pre-construction of the states.
\item[TAPA’s:]It is a tool used in concurrent systems for specifying and analysing. It also helps in model checking temporal formulas.
\item[Vereofy:]This model checker checks for operational correctness. It model checks for component-based systems.
\item[mCRL:] It studies description and analysis of distributed systems. It solves the problem in a very simple manner using the algebras CCS,CSP and ACP.
\item[UPPAAL:]It is used for real-time systems for modelling,validation and verification.
\item[Romeo:]This is same as UPPAAL which is used for modelling,validation and verification of the real-time systems.
\item[TLA+:]It is commonly called as Temporal Logic Of Actions. It combines logic of actions with temporal logic. In concurrent systems TLA+ is used in describing its behaviour.
\item[AlPina:]It is commonly called as Algebraic Petri Nets Analyser.It provides model checking for algebraic petri nets.
\item[McErlang:]It is a model checker used in checking the programs written in erlang language.
\end{description}

\section{Technology}
\label{tech}

Model checking then, used explicit state traversal where the reachable state space was traversed to find the errors violating the safety properties. It consumed lot of space in the computer memory because each state of the system was stored in large hash table \cite{Mironov2006}. In order to improve this space consumption in explicit state model checker various techniques came into existence \cite{McMillan1992}. SPIN model checker was the most successful explicit model checker. The goal of this was to overcome the state explosion problem where the states of the model were represented symbolically \cite{McMillan1992}.

Later in mid-80's Binary Decision Diagrams as a new data structure came into existence for symbolical representation and manipulating Boolean functions efficiently known as Symbolic model checking with BDDs \cite{Berard}. BDDs could handle much larger designs with hundreds of state variables representing Boolean functions \cite{ErichGamma1995}. There existed some shortcoming in BDDs as well. They became too large to handle as they used canonical representation. BDDs required uniform variable ordering along the paths and it sometimes happened that no space efficient variable ordering existed. This was time consuming and needed manual intervention \cite{McMillan1992}.

There came into existence the SAT procedures as an alternative approach to model checking. Unlike BDDs, it didn’t use the canonical representation. It became one of the most efficient implementation. It overcame the state explosion problem faced by BDDs \cite{McMillan1992}. 
In late 90s, researchers came up with the idea of Bounded model checking which uses SAT solvers to the model checking problem. Bounded model checking technique do a fast exploration of state space overcoming the shortcomings of the previous approaches using the SAT procedures instead of BDDs where the SAT has a depth first search nature \cite{McMillan1992}. This method is applicable for properties which include safety and liveness where it checks whether a given set of states is reachable, and detects loops in a system’s state transition graph.

\section{Example to illustrate the new technique}\cite{D.Jackson}
\label{Example}

Application of Model Checking ranges from simple coffee machines to nuclear plants which are undoubtedly critical and the failure of which may cause economical and physical damages. Considering an example of a coffee machine, where the system is fed with a sensitive data to check the behaviour of the system as it is supposed to behave. This is known as testing. 
\begin{figure}[h!]
\centering
  \includegraphics[width= 0.5\textwidth]{flower.png}
\caption{Finite states of a coffee machine.}
\end{figure}
 A coffee machine consists of a set the following above states which are depicted in circles and relations as arrows between the states. Arrows are given with labels representing actions. The combination of this set of states and relations is known as ``automaton". If the given action on an arrow connecting both the states is satisfied, then automaton in a given state changes to another state. 
 
Initially the machine is at state ``Start" and it ``waits" for a coin. If a coin is provided then the machine change state to the ``Button" state where two options are possible: to press the ``k" button and then go to the ``Coffee" state, or to press ``t" and go to the ``Tea" state. After serving the corresponding drink, the machine goes to the ``Glass" state and it gives a glass with the chosen drink to then go back to the ``Start" state.
\paragraph{Example 1}
The property ``Always, after the machine gets a coin and the user press a button, it gives coffee or tea", can be written in temporal logic as:
ALWAYS (IF Button THEN (SOMETIME-IN-THE-FUTURE (Coffee OR Tea)))
Words in upper-case are temporal logic ``connectives" or ``operators", and the other words represent the interaction between the machine and the user. The above expression is a ``formula" of temporal logic.

How can one see that the given automaton satisfies a formula? We can explain it by using the above formula and the automaton modelling the coffee machine.

Let us assume the current state of the automaton is the initial ``Start" state. Let A and B be statements, then ``ALWAYS A" means that A must be true in all the states of the automaton. ``IF A THEN B" means that whenever A is true in a given state, so is B. ``A OR B" means that at least one of A and B must be true in the state. Finally ``SOMETIME-IN-THE-FUTURE A" means that it must exist a state in the future of the current state where A is true.

It is then possible to check that the above formula is satisfied by the automaton, since from the state ``Button" (after a coin is inserted) it is possible to find a state in the future such that the actions ``coffee" or ``tea" are possible.
\paragraph{Example 2}
Let us consider now the following property: ``Always, after pressing a button the machine will serve coffee and then tea immediately afterwards". We can write this sentence as follows:

ALWAYS (IF Button THEN (Coffee AND NEXT Tea))
Here NEXT is a connective formalising the ``immediately after" English expression. As for the previous example it is possible to check whether the automaton satisfies the property. In this case we can see that it is not the case, since from the state ``Button" one can reach the state ``Coffee" and ``Tea", but from the ``Coffee" state it is not possible to go immediately after to the ``Tea" state. This property guarantees that the machine will never allow to get coffee and then tea by paying only once \cite{D.Jackson}.

\section{Challenges Faced}
\label{Challenges faced}

\begin{itemize}
\item Learnt the usage of Github: It is a website used for storing and presenting our files. Git is a decentralized version control system that is used by a number of open source projects, most notably perhaps the Linux kernel. GitHub is a new hosted Git repository service that's being called a ``social network" for programmers and with good reason. In my project it helps in communication between me and my supervisor by providing information to assist in evaluating the tools and making an informed decision.
\item Learnt the usage of LATEX: It is a document preparation system similar to that of a Microsoft word where the similarities end here. Preparing a document with LATEX consists of using a text editor to edit a Latex source file with the .tex extension. And then running a latex program to convert the source file to a document interchange format like PDF etc. Doing in LATEX provides a good typography which provides a good impression on the content of the document and is platform independent unlike MS word which runs only on windows. It's much better than copy+paste since it can be changed by changing just the definition. Even more, Latex allows people to write programs in their documents. 
\end{itemize}

\section{Conclusion of literature survey}
\label{conclude literature survey}

Model checking is used in many areas including both the hardware the software fields. It helps in considering only subset of the system requirements leading to the improved efficiency by supporting partial verifications \cite{Palshikar2004}. Compared to simulation and testing, model checking uses shorter time for verification as shown by many case studies. It can also deal with the states which are larger \cite{Palshikar2004}.

There are shortcomings that still need to be answered:
\begin{itemize}
\item There is no way to translate automatically the requirements into its own modelling language defined by its model checking tool. This has to be done manually.
\item Some of the properties which are to be verified are difficult to express in the notation.
\item Model checking involves much number of states consuming extra efforts in checking parts of the model separately. 
\end{itemize}
Despites these shortcomings the model checking is an important and successful area in verifying the models by early detection of the errors \cite{Havelund}.

\chapter{Running The Alloy Analyser With Example: Coffee Machine}

To facilitate the lightweight modelling object, Daniel Jackson, with the assistance of others at the Software Design Group, a declarative modelling language was designed. It allows for writing Z-style specifications in ASCII \cite{J.M.Spivey1989}, and, being close to first-order, is analyzable via translation into SAT . A platform is developed to perform this analysis which is known as Alloy Analyser \cite{Yeung2005}.

Specification of Alloy consists of signatures, facts, functions, predicates and assertions. Signatures declare the types used in the specification, and the definitions of the types fields. Types in Alloy are hierarchical in the form of a tree; a type may have multiple subtypes but at most one supertype \cite{JonathanEdwards}. In addition, all types descend from a common ancestor, which is called univ. The types and fields defined in signatures form the set of relations that are used in the specification \cite{Yeung2005}.

Facts are logical formulae or constraints over relations. They may be nested via standard logical operators, such as disjunction , conjunction , and negation . The value of a formula is thus always Boolean \cite{Yeung2005}.

Predicates are logical formulae that are evaluated on zero or more arguments. They can be called within the model or used to run an analysis of the model. Given a predicate to analyze, the Analyzer finds a solution that satisfies both the facts and the predicate, or returns that no such solution exists (within the given scope bounds, which are discussed in the next section) \cite{Yeung2005}.

Assertions are logical formulae whose validity we want to check. That is, given the signatures and facts, we want the Analyzer to help us determine whether an assertion always evaluates to true, and if not, provide a counterexample that demonstrates otherwise. The natural way to do this is to conjoin the facts of a specification with the negation of the assertion, and translate this compounded formula into SAT \cite{Strichman}. If no solution can be found, then this means that the assertion is always true when the constraints are true (within the given scopes), or that the constraints are inconsistent and always false. The latter case implies a faulty specification. On the other hand, if a solution is found, then it illustrates a counterexample case in which the constraints are true, but the assertion is false. 

Describing some aspects of a system (but not the entire system), constraint it to exclude ill-formed examples and checking the properties about it is the main goal of writing a model. The property of allow always holds for problems up to size X or if the property does not hold good, it provides a counterexample \cite{Yeung2005}.

Apart from the similarities of Alloy with other existing languages and modelling techniques, there are several other differences as well:
\begin{itemize}
\item Finite scope check: After analysing the model, the scope (size) must be specified to the model. The analysis is sound and it never returns false positives, but incomplete because it checks the things only upto a certain limit \cite{DanielJackson}. However it is complete upto the scope. Counterexample being smaller than the specified scope is never missed. Smaller scope checks are extremely valuable for finding errors. 
\item Infinite model: Unlike traditional model checking models written in alloy do not reflect that analysis is finite\cite{D.Jackson}. That is, components of the system and how they interact will be described, but do not specify as to how many components there can be. 
\item Declarative: As opposed to ``operational" or ``imperative" modeller which asks ``How can I accomplish X" , a declarative modeller answers the question ``How would I recognise that X has happened" \cite{DanielJackson}.
\item Automatic analysis : Alloy can be automatically analyzed unlike some other declarative modelling languages like Z, the object language of UML\cite{J.M.Spivey1989}. 
Examples of the system and the counterexamples to claims made about the system can be generated automatically.
\item Structured data: Alloy is a rich way to describe states by supporting the complex data structures, such as trees.
\end{itemize}

\section{Boolean translation of the Alloy constraint}
\label{Bool Transl}

By placing a bound on the universe of atoms, we will be able to solve the constraints in first-order logic. By doing so, the search space becomes finite and then translating the constraints into the Boolean form finally finding the solution with a SAT solver \cite{Strichman}. The SAT solver finds a solution to the satisfiability(SAT) problem: 

Given a Boolean function f(x1,..,xn), return an assignment of Boolean values to xi such that f evaluates to true, or prove that no such assignment exists. The solution is mapped back to the original constraint problem in a manner comprehensible to the author of the constraints \cite{Yeung2005}.

For our project, it is only necessary to have a basic understanding of how the translation into Boolean logic works in Alloy. 
 
``The universe of atoms is bounded by a user-defined or inferred scope for each type used in the object model. Consider a binary relation .
\begin{equation}
r : X \rightarrow Y
\end{equation} with the scopes of X and Y set to m and n, respectively. Then, r can be represented as an m-by-n Boolean matrix where a value of true in the i-th row and j-th column means that the i-th element of X is related to the j-th element of Y. To translate a constraint over r, one simply replaces the constants in the Boolean matrix with variables. The translations for most operations follow nicely; for example, union and intersection of relations can be translated as pairwise disjunction and conjunction of the variables, respectively" \cite{Yeung2005}.

In the Alloy Analyser preference panel, we can set the choice of the SAT solver. For almost many of the analyses, the choice of the SAT solver doesn't matter. The emphasis of the Alloy is on the systems involving complex structured state. It is also used to analyse and model almost all kinds of system including name servers, network configuration protocols, access control, telephony, scheduling, document structuring, key management, cryptography, instant messaging, railway switching, filesystem synchronisation, semantic web. 

I choose this approach because it allows us to begin with a simple model, apart from imitating the actual modelling process, by using only a small part of Alloy syntax and gradually with more advanced syntax as it is needed. Typically, formulas are temporal logic ones and interpretations are state machines. But, they don't have to be.

\section{Example: A Coffee Machine} 
\label{Ex: Coffee machine}

It begins with a simple model of a Erroneous Coffee machine. The Coffee machine is capable of accepting two pence coins and returning one pence coins. It dispenses only one type of Coffee costing one pence each. As the coin gets inserted the customer has to push a button to receive the Coffee and then must push another button to receive their change. The simplifying assumptions are made that the machine always has sufficient Coffee and change. The user when pushes a button for a Coffee he actually collects the Coffee from the coffee dispenser and similarly for the change. Even though the errors which occur when these tasks are interrupted problems occur could be considered, but these tasks could not be considered as a post-completion error. On the interaction with the Coffee machine, the primary goal is to retrieve the Coffee and our secondary goal, or sub-goal, is to retrieve the change. Here the post completion error occurs when the customer retrieves the Coffee but forgets to collect their change money. This example is similar to the one given by Curson and Blanford \cite{P.Curson}.

This is started up by a Finite state automata of a simple coffee machine.

\begin{itemize}
\item[Input:] Coini, Cofb,Stopb.
\item[Outputs:]Coino, Cofo.
\end{itemize}
\begin{figure}[h!]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,
                    thick,main node/.style={circle,draw,font=\sffamily\small\bfseries}]
                    

  \node[main node] (Initial)[] {Initial};
  \node[main node] (Wait) [right of=Initial] {Wait};

  \path[every node/.style={font=\sffamily\small}]
    (Initial)edge [loop above] node {Cofb/-} (Initial) 
              edge node [] {Coini/-} (Wait)
              edge [loop below] node {stopb/-} (Initial)
               
    (Wait) edge [bend left] node [above] {Cofb/Cofo} (Initial)
           edge [loop above] node {Coini/Coino} (Wait)
       edge [bend left] node [below] {stopb/Coino} (Initial);
             
 \end{tikzpicture}
 \caption{Finite State Automata representing a Coffee machine}
\end{figure}


The Alloy based model of Coffee machine is shown in Appendix A. There is a error in the model as then coffee machine fails to retrieve the coffee. This error is discovered by examining the situation and also examining a model of scenario by using the Alloy Analyser. 

\section{Dissecting the Coffee Machine model}
\label{Dissecting Cooffee machine}

A model is constructed which is considered as a representative of the Coffee machine described. Initially, the possible states of the Coffee machine must be decided. The machine can be either: waiting for the money to be inserted (labelling this as a `Reset’ state); having accepted the money and waiting for the Coffee button to be pushed (`Coin state’); after the Coffee has been dispensed (the ‘Coffee’ state); or having returned change to the customer (the `Change’ state). The signature declaration is as follows \cite{Boyatt}:

\begin{verbatim}
abstract sig CofState{}
one sig Reset, Coin, Coffee, Change extends CoffeeState{}
\end{verbatim}

 It defines a set named CoffeeState. Here we can define relations that have this signature as their domain. Relations defined here behave like fields of an object in the OO paradigm. Another way to enforce that constraint would be to mark CoffeeState as abstract. An abstract signature only contains atoms which are also contained in one of its extending signatures. Exception: if there are no extending signatures, then the abstract keyword is ignored.

The state of the Coffee machine consists of its current state as defined above, the amount of money that has been entered by the customer and the type of Coffee, if any, in the dispenser. Since it is marked one, there will always be exactly one instance of it. We declare a signature, Coffee, to hold the state of the Coffee machine at one instant in time \cite{Boyatt}.

\begin{verbatim}
sig Cof{
	balance: one Int,
	state: one CofState,
	op: OP,
	dispenser: lone CofType
}
\end{verbatim}

 The body of this signature declares four relations that Coffee machine needs: balance, state, op, and dispenser. Note that when multiple fields are declared within a single signature body, they are separated by commas. Where a lone indicated ``0 or 1", a one indicates ``exactly 1". The field labelled `op’ in the Coffee is not yet mentioned. So far, the model is considered with respect to Coffee machine and not with respect to the customer and their interaction with the Coffee machine. If considered the interaction of the customer with the Coffee machine, then we can identify various actions the customer can perform: Entering a coin, choosing a Coffee and requesting the change. Hence, an additional signature to record what the customer is doing to initiate the changes in the state of the Coffee machine is declared and is illustrated evolving scenario. The action of the customer is observed at each stage in the trace. This information is just an illustration which aids the understanding of examples produced by the analyser \cite{Boyatt}.
 
\begin{verbatim}	
abstract sig OP{}
one sig ENTERCOIN, PUSHCOF, PUSHCHANGE, RESET extends OP{}
\end{verbatim}

To represent the evolving state of the Coffee machine we must constrain the possible states of our model. Predicates are used to represent operations on the state of the Coffee machine and describe the relationship between two instances of the Coffee signature. We can think of these as the `before' (c) and `after' (c') states. We present the predicate that presents the customer, who has just inserted a coin, selecting the Coffee to purchase \cite{Boyatt}:

\begin{verbatim}
pred buycof[c, c': Cof]{
	c.state = Coin && 
	INT/gte[c.balance,int(1)] &&
	c'.balance = INT/sub[c.balance, int(1)] &&
	no c.dispenser &&
	c'.dispenser = Cof1
	c'.state = Coffee
}
\end{verbatim}

This predicate, although it represents an operation, is a constraint. It constrains the state before selecting the coffee (c) and constrains the state after selecting the coffee (c'). For example, ``c.state = Coin" ensures that the coffee machine is in the `Coin’ state initially and then ``c'.state = Coffee" ensures that it is in the `Coffee' state afterwards. This is a familiar and expressive approach in state-based specifications facilitating the use of Alloy. This is a familiar and expressive approach in state-based specifications facilitating the use of Alloy. As the amount of money is being considered that has been entered into the machine, integer operations are used in the util/integer package using them with the prefix `INT’. Sufficient funds must be available to purchase Coffee and subtracting the cost of the Coffee from the available balance. Also representing the Coffee being dropped into the dispenser. Similarly, other operations on the state of the Coffee machine, such as entering coins and returning change, are described using this approach to predicates \cite{Boyatt}.

The aim is to examine the dynamic behaviour of the Coffee machine and must therefore introduce a mechanism to capture the evolving state of the Coffee machine but still allow for the model to be statically checked. Alloy already has this mechanism in the form of traces. The predicate describing the valid traces in the system is \cite{Boyatt}:

\begin{verbatim}
pred traces{
	init[CO/first[]] &&
	all c:Cof-CO/last[] | let c' = CO/next[c] |
	((entercoin[c,c'] && c'.op = ENTERCOIN)
	or
	(buycof[c,c'] && c'.op = PUSHCOF)
	or
	(askchange[c,c'] && c'.op = PUSHCHANGE)
	or
	(reset[c,c'] && c'.op = RESET))
}
\end{verbatim}

This says that the initial condition holds for the initial time step, and then for all subsequent times the machine must change in accordance with one of the four predicates: entercoin, buycof, askchange, and reset. Additionally, the actions of the customer are defined here to help annotate any examples returned. The four actions by the customer are: entering a coin (ENTER-COIN), pushing the coffee button (PUSHCOF), pushing the change button (PUSHCHANGE) and removing their change from the machine (RESET) \cite{Boyatt}. The ordering library module used here is generic, usable with any signature type and not specific to this example.

\section{Checking for Post-Completion errors}
\label{Post completion error check}

Sequences of events must be defined representing a single interaction of the customer with the Coffee machine in order to check the post-completion errors. A single interaction of the model shall be referred to as `transaction’, consisting of a trace that begins with the initial state (awaiting coins) and finishes with the Coffee machine resetting for the one and only time in that transaction \cite{Boyatt}.

\begin{verbatim}
pred transaction{
	traces &&
	(CO/last[]).op = RESET &&
	RESET !in (Cof - CO/last[]).op
}

one sig Goal {goals : set CofState } {goals = Coffee }
one sig Subgoals {subgoals : set CofState }{subgoals = Change }

assert goalsmet{
	transaction => let m = CO/max[state.(Goal.goals)] |
	some m => all sg: Subgoals.subgoals | state.sg in CO/prevs[m]
}
check goalsmet for 5
\end{verbatim}

Also shown above is the mechanism for representing the goal and sub-goals, the order in which they are satisfied being of great importance to the post-completion errors which are being considering. We define the main goal to be the dispensing of the Coffee, and the sub-goal to be the dispensing of the change. For a post-completion error to occur in our model, the Coffee would be dispensed before the change is dispensed. In the goalsmet assertion, it is stated that for valid transactions all subgoals (sg) must occur in states before the state in which the goal occurs (m). Assertions are something we believe to be true about our model and the check command asks Alloy to provide us with the counterexamples, demonstrating that it is possible for the primary goal to be achieved prior to all of the sub-goals being satisfied.

Now, the model has been constructed and also the appropriate mechanisms to represent are also introduced and check for the post completion error. The properties of the model using the tool itself can be explored. Checking the goalsmet assertion quickly provides a counterexample that should, in this case, already be easily identifiable and simple to confirm by a visual inspection of the model. The current version of the model is constructed in a way that prevents the machine from engaging in behaviour where the change is dispensed before the Coffee. Addressing this post-completion error suggests modifications to the actual Coffee machine. Of course, any Coffee machine that requires a button requesting change after the Coffee dispensed will have a post-completion error. Perhaps a solution is to, after the Coffee has been selected, noisily return the change to the customer just before the Coffee itself is dispensed.

\begin{figure}[h!]
 \centering
  \includegraphics[width= 1\textwidth]{viz1.png}
\caption{Finite states of a coffee machine.}
 \end{figure}
 
 \section{Extending the Coffee machine}
\label{Cofee machine ext}

Now, several possible extensions and revisions to our Coffee machine model are considered \cite{Boyatt}. The properties that have already been defined can be checked with each revision, specifically those regarding post-completion errors \cite{Boyatt}. Each of these extended models shows how through the experimentation and interaction with the model develop them beyond their initial design whilst retaining the properties and valuable checks has been developed \cite{Boyatt}.

\subsection{Allowing different types of coins}
\label{Allowing different types coins}

Suppose we expand this model to allow the coffee machine to accept both one and two pence coins. We now have two initial steps, one that represents the insertion of a 1p coin and the second for the insertion of a 2p coin \cite{Boyatt}:

\begin{verbatim}
pred enter2pcoin[c, c': Cof] {
	c.state = Reset &&
	c'.balance = INT/add[c.balance, int(2)] &&
	c'.dispenser = c.dispenser &&
	c'.state = Coin
}

pred enter1pcoin[c, c': Cof]{
	c.state = Reset &&
	c'.balance = INT/add[c.balance, int(1)] &&
	c'.dispenser = c.dispenser &&
	c'.state = Coin
}
\end{verbatim}
They must also account for two different reset conditions. Customers are allowed to insert 2p coins into the machine for Coffee that only cost 1p and must therefore return change of 1p. However, should a 1p coin be inserted into the Coffee machine, it is not necessary to give change so which can reset immediately under these conditions. There are two reset possibilities \cite{Boyatt}:

\begin{verbatim}
pred reset[c,c' : Cof]{
	c.state = Change &&
	c'.balance = c.balance &&
	c'.dispenser = c.dispenser &&
	c'.state = Reset
}

pred reset2[c,c' : Cof] {
	c.state = Coffee &&
	c.balance = 0 &&
	c'.balance = c.balance &&
	c'.dispenser = c.dispenser &&
	c'.state = Reset
}
\end{verbatim}

The first allows the machine to return to the reset state after the change has been dispensed and the second allows the machine to be reset immediately after the coffee is dispensed if and only if there is no chance to dispense \cite{Boyatt}. This model is listed in appendix B.

\subsection{Allowing different types of Coffee}
\label{Different Coffees}

Our Coffee currently only allows for the selection of one type of Coffee. Clearly, real life Coffee machines allow for the selection of a wide variety of products. In accordance to it, the purchase of both a small Coffee, costing one pence, and a large Coffee, costing two pence is allowed. Whereas before there was a single operation, buycof, to represent the purchase of a Coffee and now introducing an operation for each of the different types of Coffee \cite{Boyatt}.

\begin{verbatim}
pred buysmallcof[c, c': Cof] {
	c.state = Coin &&
	INT/gte[c.balance,int(1)] &&
	c'.balance = INT/sub[c.balance, int(1)] &&
	no c.dispenser &&
	c'.dispenser = SmallCof
	c'.state = Coffee
}

pred buylargecof[c, c': Cof] {
	c.state = Coin &&
	INT/gte[c.balance,int(2)] &&
	c'.balance = INT/sub[c.balance, int(2)] &&
	no c.dispenser &&
	c'.dispenser = LargeCof
	c'.state = Coffee
}
\end{verbatim}

 Additionally, the actual retrieval of the Coffee from the dispenser can now be considered. Until now, there was no consideration of the customer retrieving the Coffee after the machine has dispensed it \cite{Boyatt}. A new state, GotCoffee, to represent the state of the machine after the Coffee has been retrieved is introduced. (The machine may, for instance, detect this with a sensor on the dispenser door.) For all of these modifications there is an introduction of the actions of the customer in the form of the OP signature declarations and the traces model is adapted accordingly \cite{Boyatt}.
 
\begin{verbatim}
pred getcof[c,c':Cof] {
	c.state = Coffee &&
	c'.state = GotCoffee &&
	some c.dispenser &&
	no c'.dispenser &&
	c'.balance = c.balance
}
\end{verbatim}

 This model is listed in appendix C.
 
\subsection{Purchasing more than one Coffee}
\label{Purchasing more than one coffee}

Suppose the customer inserts a two pence coin but then only purchases Coffee costing one pence. Selecting multiple Coffees from the machine would be allowed. A simple extension to the existing getcof predicate allows there to be a valid transition from the Coffee state back to the Coin state if a non-zero balance remains \cite{Boyatt}. If the customer had acted as described, entering a two pence and selecting a one pence Coffee, it would allow the machine to return to the state as if the customer had simply entered a one pence coin. This demonstrates that the state of the model can depend quite specifically on the state of the machine before the operation \cite{Boyatt}.

\begin{verbatim}
pred getcof[c,c':Cof] {
	c.state = Coffee &&
	some c.dispenser &&
	no c'.dispenser &&
	c'.balance = c.balance &&
	((INT/gte[c.balance,int(0)] => c'.state = Coin )
	or c'.state = GotCoffee)
}
\end{verbatim}

This model is listed in appendix D.

\subsection{Inserting more than one coin}
\label{Inserting more than one coin}

In the final example, the customer is allowed to insert more than one coin into the Coffee machine \cite{Boyatt}. This modification simply requires us to allow the machine to return to the state where it accepts coins but without resetting the stored balance \cite{Boyatt}.

\begin{verbatim}
pred enter2pcoin[c, c': Cof] {
	c.state = Reset &&
	c'.balance = INT/add[c.balance, int(2)] &&
	c'.dispenser = c.dispenser &&
	(c'.state = Coin or c'.state = Reset)
}
pred enter1pcoin[c, c': Cof] {
	c.state = Reset &&
	c'.balance = INT/add[c.balance, int(1)] &&
	c'.dispenser = c.dispenser &&
	(c'.state = Coin or c'.state = Reset)
}
\end{verbatim}

This model is listed in appendix E.

Now, there is a reasonably complicated Coffee machine. It began with a Coffee machine that could accept one single coin and dispense one type of Coffee \cite{Boyatt}. Now there is a model of a Coffee machine that can accept multiple coins of different values, provides a selection of different Coffee types and allow for the purchase of multiple Coffees. Throughout these modifications the ability to look for post-completion errors has been retained. The trace of the sequences of operations that results in a post-completion error has lengthened due to the extra complexity of the model \cite{Boyatt}.
 
\chapter{Theoretical Background To The Project}
Alloy can be considered as a natural choice for representation of interactive systems \cite{P.Curson}.  The project will be structured as follows:
 Firstly, introducing the key concepts of Alloy. Then, describe the approach of analysing the model with the Alloy Analyser and applying it to an example.
It is difficult to validate the system with the specifications and requirements \cite{Boyatt}. The     validation task would be easier if we make the specifications executable, giving the immediate feedback of the behaviour of the future software to the user \cite{Boyatt}.

The Boolean level of representation of the model-checking task with the computation engine that supported the required set of operations gave rise to Symbolic model checking \cite{Bryant1986}. Ordered Binary Decision Diagram (OBDD) was the first approach combining the efficiency and expressive power. Recently, based on Davis-Putnam-Logemann-Loveland (DPLL) algorithm, Boolean satisfiability (SAT) checkers have greatly extended the reach of bounded model checkers \cite{Bryant1986}.

OBDDs and DPLL –based checkers compliments each other. OBBDs readily deal with quantified Boolean formulas (QBF) where as DPLL cannot \cite{Bryant1986}. SAT problem which are completely intractable for DPLL are trivial with OBDDs. SAT checkers are insensitive to the number of variables \cite{Strichman}.

\section{A view from the Engine Room}
\label{View from engine}

The first symbolic model checkers used Ordered Binary Decision Diagrams (OBDDs) \cite{Bryant1986} to represent system transition relations and sets of system states \cite{McMillan1992} . All the steps required for a model checking is expressed as a series of operations on these representations, without enumerating individual states or transitions. Recently, Bounded and Inbounded model checking has been devised which use Boolean satisfiability (SAT) solvers as a computational engines \cite{McMillan1992}. Combining the methods which have a SAT solver work on a detailed system model and OBDDs operate on a abstracted model, is more powerfull than operating on its own \cite{Clarke1999}.

Model checkers are now able to handle the complex verification problems coming from real world hardware and software designs with the help of Boolean methods \cite{ErichGamma1995}. By giving the importance of Symbolic model checking, I take this opportunity to examine the capabilities of SAT solver \cite{Bryant1986}.

\subsection{Making the Specifications Executable}
\label{Spec Exec}

When the given task is to prove that the given formula is unsatisfiable, we find an error in the design by using the SAT solver which is typically used by verification problem \cite{McMillan2003}. To prove that the formula is unsatisfiable, it is currently highly favourable to use DPPL method \cite{M.Davis1962} for solving SAT problems by backtracking search among complete SAT algorithms. By doing so, it has gained a remarkable progress in speed and capacity \cite{M.Moskewicz2001}.

I would like to be working on the use of Alloy as the formalism used for the formal analysis of models. Alloy is a lightweight modelling language for software design. By using the Alloy Analyzer, it is amenable to a fully automatic analysis \cite{D.Jackson}. It also provides a visualizer for making sense of solutions and counterexamples it finds \cite{P.Curson}.

\section{Running the Alloy Analyser}
\label{Run Alloy Analyzer}

At this point, Alloy has to be installed downloading alloy4.dmg file (available at alloy.mit.edu), and double click on Alloy4 icon. Alloy analyser can be run on other platforms just by downloading the alloy4.jar file then double-click on the jar file or type:

\begin{center}
Java –jar alloy4.jar
\end{center}

in the console.

\section{The Alloy Analyser Layout}
\label{Alloy Analyser layout}

Once you get Alloy up and running, you will be presented with a screen with two sections, looking something like this:

 \begin{figure}[h!]
\centering
 \includegraphics[width= 1\textwidth]{alloyblank.png}
\caption{Alloy Layout.}
 \end{figure}
 
\subsection{Toolbar}
\label{Tools}

The main toolbar of the Alloy Analyser provides quick access to the most commonly used operations:
\begin{itemize}
\item New : Creates a new text file in the editor.
\item Open : Opens an existing Alloy model in the editor.
\item Reload : For each file currently open in the editor, reload its content from the file system.
\item Save : Saves the currently active model in the editor.
\item Execute : Executes the most recently executed command. Executes the first command from the file if no command has been executed so far.
\item Show : Displays the most recent counterexample or instance.
\end{itemize}

\subsection{Editor Panel and Message Panel}
\label{Editor and Message Panel}

The user interface consists of the editor panel and the message panel. The relative sizes of panels may be adjusted by clicking and dragging the split bars that separate the panels \cite{DanielJackson}.
\begin{itemize}
\item 	Editor panel: Contains a tabbed text editor for modifying Alloy models. It supports tabbing so you can edit multiple text files simultaneously. It also supports error highlighting during model compilation.
\item 	Message panel: Displays the results of analysis. Each counterexample and each satisfying instance will have a clickable hyperlink. Clicking on it will launch the Alloy Visualizer to display the counterexample or instance.
\end{itemize}
The message panel is also used for general status messages and error messages.

For example, if a model cannot be compiled, an error message is displayed, and the error will be highlighted in the source Alloy model.

\subsection{Options and Preferences}
\label{Options & Preference}

The preferences can be set by clicking the options menu.
\begin{itemize}
\item SAT solver : Alloy4 comes prepackaged with a selection of SAT solvers. By default, the pure Java solver ``SAT4J” is chosen since it runs on every platform and operating system \cite{DanielJackson}.

If you require faster performance, you can try one of the native solver such as MiniSat or ZChaff. But if MiniSat or ZChaff crashes due to platform or operating system incompatibility, then change the solver back to SAT4J \cite{DanielJackson}.

\item Warnings are Fatal : By default, a model that contains one or more compilation warnings cannot be executed.
\item Maximum Memory to Use : The amount of memory to allocate for Alloy4; larger and more complicated models require more memory.
\item Message Verbosity : This controls how verbose the messages will be.
\item Font Size : This controls the font size in the editor panel and the message panel.
\item Font : This controls the font in the editor panel and the message panel.
\item Tab Size : This controls the tab size in the editor panel.
\item Skolem Depth : This controls the maximum depth of alternating universal-vs-existential quantifier that we will permit when generating a skolem function. If a formula exceeds this depth, a skolem function for it will not be generated \cite{DanielJackson}.
\item Unsat Core Minimization Strategy : This controls the unsat core. The fast strategy performs no minimization at all. The medium strategy uses a hybrid algorithm that attempts to reduce the core size. The slow strategy guarantees that, at the logic level, the core is a locally minimum core \cite{DanielJackson}.
\item Visualize Automatically : If this option is enabled, after executing any command, the Alloy Analyser will automatically load the visualizer to visualize the counterexample or instance (if any)\cite{DanielJackson}.
\item Record the Kodkod Input/output : If this option is enabled, after executing any command, then Alloy Analyser will record the Kodkod input model generated for that command, as well as the Kodkod solution corresponding to that command \cite{DanielJackson}.
\end{itemize}

\section{Performing an Analysis on Alloy Models}
\label{Alloy Performance}

A run command is used to search for solutions that satisfy the specification and a predicate, while a check command is used to search for the solutions that satisfy the specification but violate an assertion \cite{DanielJackson}.

To run either type of analysis, select the command to be run from the run menu, or click the ``run" toolbar button \cite{DanielJackson}.

The run menu will display the list of check and run commands present in the model. The commands can be executed one at a time, or click ``run all" to execute them all.

The run toolbar button will executes the most recently executed command. If no command has been executed, it will execute the first command in the model.The analysis will either terminate with a solution or indicate that one cannot be found within the search space specified by the type scopes of the command.If a solution is found, it can be displayed by clicking on the blue clickable hyperlink in the message panel.Or, if you enable ``visualize automatically" in the options menu, then the option will be displayed automatically \cite{DanielJackson}.

\subsection{Loading the Model}
\label{Model loading}

When executing commands in an Alloy model, Alloy always uses the current content in the text editor as the model to compile.

Therefore, if made some changes to the model, there is no need of saving them before running.

\subsection{Troubleshooting}
\label{Troubleshoot}

Here are some of the common errors that may be encountered \cite{DanielJackson}:
\begin{itemize}
\item Higher-order quantification: The declaration for a variable in a quantified formula is higher-order and cannot be reduced via skolemization. Solving such formulas will always take a significant amount of time and memory unless the scope is very, very small, since every combination must be enumerated. Thus, the Alloy Analyser will not attempt to solve such a formula.
\item The module X cannot be found: The Alloy Analyser cannot find the desired model to import in an ``open” statement.
\item No scope for top-level type X in command: A top level type is one that has no supertype (other than the implicit universal type univ). All such types must be given a scope for execution, with the following exceptions: 1) The command has no explicit scopes at all – all top-level types are given an implicit default scope of 3.
2) Type X is defined as ``abstract" – in this case, if all children of X are scoped, then the scope of X is inferred and need not be set explicitly.
\end{itemize}

\subsection{Things that may affect Execution speed}
\label{Things affecting execution speed}

Various things may affect the speed of analysis which include:
\begin{itemize}
\item The size of the type scoped specified in the command. The difficulty of the analysis increases with scope in a quicker than linear fashion \cite{DanielJackson}.
\item The SAT solver used. By default, the SAT4J solver is used. However, other solvers may fare better in specific models. The SAT solver may be changed by clicking the options menu \cite{DanielJackson}.
\end{itemize}

\subsection{About Module Paths}
\label{Module Paths}

Alloy models may contain ``open" statements, like this one:

Open util/integer

The Alloy ``open" statement is roughly similar to Java ``import" or the C/C++ ``include" in that it tells the tool to look at some source in another file.Alloy will look for util/integer.als in two places:First of all, if the module is one of the sample model that comes with Alloy4, it will load it. This includes all the ``util" modules such as util/ordering and util/Boolean \cite{DanielJackson}.
Alloy 4 contains a number of utility modules that provide common operations on graphs, integers, etc. Here is a list of the modules and a short description for each module \cite{DanielJackson}:
\begin{itemize}
\item module util/boolean: Creates a Bool type with two singleton subtypes: True and False. 
\item module util/graph[node]: Utilities for common operations and contraints on graphs. 
\item module util/integer: Utilities for using integers in Alloy. 
\item module util/natural: Utilities for using the set of nonnegative integers (0, 1, 2, ...). 
\item module util/ordering[element]: Creates a single linear ordering over the atoms in elem. 
\item module util/relation: Utilities for common operations and constraints on binary relations. 
\item module util/sequniv: This module models each sequence of elements using a relation.
(This module is imported automatically if your model uses the new seq keyword. 
\item module util/ternary: Utilities for common operations and constraints on ternary relations.
\end{itemize}

\subsection{Visualizer} 
\label{visualiser}

The visualizer offers 3 views, which can be selected in its toolbar at the top.

Visualization Modes:
\begin{itemize}
\item Viz : Brings up the graphical view where each node is an atom (member of a signature) and arcs represent the relations between atoms. 
The labels, colours, and various other settings can be configured by clicking the Theme button. 
\item Tree : brings up the tree view. The nodes of the tree may be expanded or collapsed to reveal or hide the values of relations. A relation node (such as that for a signature or a field) is expanded to reveal its tuples, and an atom may be expanded to reveal the value of joining the atom with the fields defined in its correponding signature. 
\item XML : Shows the instance as an XML document. As implied by its name, the XML view displays an instance in XML format. If you save the XML text, you can load the instance later from the visualizer.
\end{itemize}  

\subsection{Skolemization Relations }
\label{Skolemization relations}

Often times, quantified formulas can be reduced to equivalent formulas without the use of quantifiers.
This reduction is called skolemization and is based on the introduction of one or more skolem constants or function that capture the constraint of the quantified formula in their values \cite{DanielJackson}.

Consider the following example: 

\begin{verbatim}
sig A { r: lone B } 
sig B {}
fact {
	 some x: A | no x.r
}
\end{verbatim}

 The ``some" formula may be equivalently expressed as: 

    x' in A \&\& no x'.r 
    
x' is the skolem reation in this case. The existential quantifier ``some" is not needed because the analysis will search for the existence of the skolem realtion x'\cite{D.Jackson}.
  
\subsection{Determining the names of Skolem relations }
\label{determine skolem relations}

 The Alloy Analyzer automatically generates and assigns names to skolem relations.
 
The names can be determined by looking at the solved instance using any of the three (Text, Tree, Viz) views \cite{DanielJackson}.
For instance, in the above example, the name \$x may have been assigned to the skolem relation x'. 

\subsection{Using skolem relations }
\label{Use of skolem relations}

Skolem relations are displayed in the output like any other relation in the original model. Hence, its visualization may be conspicuous.

\section{Summary}
\label{summary}

This project is all about understanding the engine behind model-checking. SAT-Technology is emerging as a central engine used in model checking tools. The principle behind it is very simple: Formulate everything at the (logical) gate-level, and then run a SAT solver. The devil is then in the details. This project is about exploring this fascinating and recent connection. Either gaining some overview, or exploring a concrete application.

The field has advanced considerably due to both clever ideas and careful engineering \cite{Bryant1986}. Model checking and many other application areas have directly benefited from these tools. It is important that the research community keeps pushing ahead with new approaches and new improvements in Boolean reasoning. There remain many important problems that are beyond the reach of today's methods.


\bibliographystyle{plain}
\bibliography{reema1}


\chapter{Appendices}
\label{Appendices}
\section{A. Simple Coffee Machine}\cite{Boyatt}


\begin{verbatim}


module  SimpleCofMachine
open  util / ordering [ Cof ]  as  CO
open  util / integer  as  INT
abstract  sig  CofState  {}
one  sig  Reset, Coin, Coffee, Change extends CofState  {}
abstract  sig  OP  {}
one  sig  ENTERCOIN, PUSHCOF, PUSHCHANGE, RESET extends OP  {}
abstract  sig  CofType  {}
one  sig  Cof1 extends CofType  {}

sig  Cof  {

	balance :  one Int ,
	state :  one CofState ,
	op :  OP,
	dispenser :  lone CofType
	
}

// Give us a quick example

pred  show1 [ c : Cof ]  {}
run show1

pred  entercoin [ c , c' : Cof ]  {

	c . state  =  Reset &&
	c' . balance  =  INT/add [ c . balance , int ( 2 ) ] &&
	c' . dispenser  =  c . dispenser &&
	c' . state  =  Coin
	
}

pred  buycof [ c , c' : Cof ]  {

	c . state  =  Coin &&
	INT/ gte [ c . balance , int ( 1 ) ] &&
	c' . balance  =  INT/sub [ c . balance , int ( 1 ) ] &&
	no c . dispenser &&
	c' . dispenser  =  Cof1
	c' . state  =  Coffee

}

pred  askchange [ c , c' : Cof ]  {

	c . state  =  Coffee
	INT/ gt [ c . balance , 0 ] &&
	INT/ zero [ c' . balance ] &&
	c' . dispenser  =  c . dispenser &&
	c' . state  =  Change

}

pred  reset  [ c , c' : Cof ]  {

	c . state  =  Change  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  init [ c : Cof ]  {

	c . balance  =  0  &&
	c . state = Reset  &&
	c . dispenser  =  none

}

pred traces {

	init [CO/ first [ ] ]  &&
	all c : Cof−CO/ last [ ] | let c'  =  CO/ next [ c ] |
	( ( entercoin [ c , c' ]  &&  c' . op  =  ENTERCOIN)
	or
	( buycof [ c , c' ]  &&  c' . op  =  PUSCOF)
	or
	( askchange [ c , c' ]  &&  c' . op  =  PUSHCHANGE)
	or
	( reset [ c , c' ]  &&  c' . op  =  RESET) )

}

pred transaction {

	traces  &&
	(CO/ last [ ] ) . op  =  RESET  &&
	RESET ! in (Cof − CO/ last [ ] ) . op

}


one sig Goal{goals: set CofState}{goals = Coffee}
one sig Subgoals{subgoals: set CofState}{subgoals = Change}

assert  goalsmet  {

	transaction=>let m = CO/max[state.(Goal.goals)]| 
	some m=>all sg: Subgoals.subgoals | state.sg in CO/ prevs[m]
}

// This generates a counterexample with 5

check goalsmet for 5
\end{verbatim}

\section{B.  Coffee machine - different coins}
\begin{verbatim}
module  SimpleCofMachine
open  util / ordering [ Cof ]  as  CO
open  util / integer  as  INT
abstract  sig  CofState  {}
one  sig  Reset, Coin, Coffee, Change extends CofState  {}
abstract  sig  OP {}
one  sig  ENTER1PCOIN , ENTER2PCOIN , PUSHSMALLCOF , PUSHLARGECOF ,
GETCOF , PUSHCHANGE , RESET extends OP  {}
abstract  sig  CofType {}
one  sig  Cof1 extends CofType  {}

sig  Cof {

	balance :  one  Int ,
	state :  one  CofState ,
	op : OP ,
	dispenser :  lone CofType
}

// Give us a quick example

pred  show1 [ c : Cof ]  {}
run show1

pred  enter2pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 2 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin

}

pred  enter1pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 1 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin

}

pred  buycof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT/ gte [ c . balance , int ( 1 ) ]  &&
	c' . balance  =  INT/sub [ c . balance , int ( 1 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  Cof1
	c' . state  =  Coffee

}

pred  askchange [ c , c' : Cof ]  {

	c . state  =  Coffee
	INT/ gt [ c . balance , 0 ]  &&
	INT/ zero [ c' . balance ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Change

}

pred  reset [ c , c' : Cof ]  {

	c . state  =  Change  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  reset2 [ c , c’ : Cof ]  {

	c . state  =  Coffee  &&
	c . balance  =  0  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  init [ c : Cof ]  {

	c . balance  =  0  &&
	c . state  =  Reset  &&
	c . dispenser  =  none

}

pred  traces  {

	init [CO/ first [ ] ]  &&
	all c : Cof−CO/ last [ ] | let c'  =  CO/ next [ c ] |
	( ( enter1pcoin [ c , c' ]  &&  c' . op  =  ENTER1PCOIN)
	or
	( enter2pcoin [ c , c' ]  &&  c' . op  =  ENTER2PCOIN)
	or
	( buycof [ c , c' ] && c' . op  =  PUSHCOF)
	or
	( askchange [ c , c' ] && c' . op  =  PUSHCHANGE)
	or
	( reset2 [ c , c' ]  &&  c' . op   = RESET)
	or
	( reset [ c , c' ]  &&  c' . op  =  RESET) )

}

pred  transaction {

	traces  &&
	(CO/ last [ ] ) . op  =  RESET  &&
	RESET ! in (Cof − CO/ last [ ] ) . op

}

one sig Goal{goals: set CofState}{goals=Coffee}
one sig Subgoals{subgoals: set CofState}{subgoals=Change}

assert goalsmet {

	transaction=>let m = CO/max[state.(Goal.goals)] |
	some m=>all sg: Subgoals.subgoals | state.sg in CO/ prevs[m]
}

// This generates a counterexample with 5

check goalsmet for 5
\end{verbatim}

\section{C. Coffee machine - different coffee's}
\begin{verbatim}
module  SimpleCofMachine
open  util / ordering [ Cof ]  as  CO
open  util / integer  as  INT
abstract  sig  CofState  {}
one sig Reset, Coin, Coffee, GotCoffee, Change extends CofState {}
abstract  sig  OP  {}
one  sig  ENTER1PCOIN , ENTER2PCOIN , PUSHSMALLCOF , PUSHLARGECOF ,
GETCOF , PUSHCHANGE , RESET extends OP  {}
abstract  sig  CofType  {}
one  sig  SmallCof , LargeCof  extends  CofType  {}

sig  Cof  {

	balance :  one  Int ,
	state :  one  CofState ,
	op :  OP,
	dispenser :  lone  CofType

}

// Give us a quick example

pred  show1 [ c : Cof ]  {}
run show1

pred  enter2pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 2 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin
	
}

pred  enter1pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 1 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin
	
}

pred  buysmallcof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT/ gte [ c . balance , int ( 1 ) ]  &&
	c' . balance  =  INT/sub [ c . balance , int ( 1 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  SmallCof
	c' . state  =  Coffee

}

pred  buylargecof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT/ gte [ c . balance , int ( 2 ) ]  &&
	c' . balance  =  INT / sub [ c . balance ,  int ( 2 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  LargeCof
	c' . state  =  Coffee

}

pred  getcof [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	c' . state  =  GotCoffee  &&
	some  c . dispenser  &&
	no  c' . dispenser  &&
	c' . balance  =  c . balance

}

pred  askchange [ c , c' : Cof ]  {

	c . state  =  GotCoffee
	INT/ gt [ c . balance , 0 ]  &&
	INT/ zero [ c' . balance ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Change

}

pred  reset [ c , c' : Cof ]  {

	c . state  =  Change  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  reset2 [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	c . balance  =  0  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  init [ c : Cof ]  {

	c . balance  =  0  &&
	c . state  =  Reset  &&
	c . dispenser  =  none

}

pred  traces {

	init [CO / first [ ] ]  &&
	all  c : Cof−CO/ last [ ] | let c'  =  CO/next [ c ] |
	( ( enter1pcoin [ c , c' ]  &&  c' . op  =  ENTER1PCOIN)
	or
	( enter2pcoin [ c , c' ]  && c' . op =  ENTER2PCOIN)
	or
	( buysmallcof [ c , c' ]  &&  c' . op = PUSHSMALLCOF)
	or
	( buylargecof [ c , c' ]  &&  c' . op  =  PUSHLARGECOF)
	or
	( getcof [ c , c' ]  &&  c' . op  =  GETCOF)
	or
	( askchange [ c , c' ]  &&  c' . op  =  PUSHCHANGE)
	or
	( reset2 [ c , c' ]  &&  c' . op  =  RESET)
	or
	( reset [ c , c' ]  &&  c' . op  =  RESET) )

}

pred  transaction {

	traces  &&
	(CO/ last [ ] ) . op  =  RESET  &&
	RESET ! in (Cof − CO/ last[ ] ) . op

}

one  sig  Goal { goals :  set CofState }  { goals  =  Coffee }
one  sig Subgoals { subgoals : set CofState } { subgoals  =  Change}

assert  goalsmet  {

	transaction => let m  =  CO/max [ state . ( Goal . goals ) ] |
	some m=>all sg: Subgoals.subgoals | state.sg in CO/prevs[m]
	
}
// This generates a counterexample with 6

Check  goalsmet for 6

\end{verbatim}

\section{D. Coffee machine - multiple coffees}
\begin{verbatim}
module  SimpleCofMachine
open  util / ordering [ Cof ]  as  CO
open  util / integer  as  INT
abstract  sig  CofState  {}
one sig Reset, Coin, Coffee, GotCoffee, Change extends CofState {}
abstract  sig  OP  {}
one  sig  ENTER1PCOIN , ENTER2PCOIN , PUSHSMALLCOF , PUSHLARGECOF ,
GETCOF , PUSHCHANGE, RESET extends OP  {}
abstract  sig  CofType  {}
one  sig  SmallCof , LargeCof extends CofType {}

sig  Cof  {

	balance :  one  Int ,
	state :  one  CofState ,
	op :  OP,
	dispenser :  lone  CofType

}

// Give us a quick example
pred  show1 [ c : Cof ]  {}
run show1

pred enter2pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 2 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin

}

pred  enter1pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT/add [ c . balance , int ( 1 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Coin

}

pred  buysmallcof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT/ gte [ c . balance , int ( 1 ) ]  &&
	c' . balance  =  INT / sub [ c . balance , int ( 1 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  SmallCof
	c' . state  =  Coffee

}

pred  buylargecof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT / gte [ c . balance , int ( 2 ) ]  &&
	c' . balance  =  INT / sub [ c . balance , int ( 2 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  LargeCof
	c' . state  =  Coffee

}

pred  getcof [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	some  c . dispenser  &&
	no  c' . dispenser  &&
	c' . balance  =  c . balance  &&
	((INT/gte[c.balance, int(0)]=>c'.state=Coin) or c'.state=GotCoffee )
}

pred  askchange [ c , c' : Cof ]  {

	c . state  =  GotCoffee
	INT / gt [ c . balance , 0 ]  &&
	INT / zero [ c' . balance ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Change

}

pred  reset [ c , c' : Cof ]  {

	c . state  =  Change  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  reset2 [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	c . balance = 0  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  init [ c : Cof ] {

	c . balance = 0  &&
	c . state  =  Reset  &&
	c . dispenser  =  none

}

pred  traces  {

	init [CO/ first [ ] ]  &&
	all  c : Cof−CO/ last [ ] | let c'  =  CO/ next [ c ] |
	( ( enter1pcoin [ c , c' ]  &&  c' . op  =  ENTER1PCOIN)
	or
	( enter2pcoin [ c , c' ]  &&  c' . op  =  ENTER2PCOIN)
	or
	( buysmallcof [ c , c' ]  &&  c' . op  =  PUSHSMALLCOF)
	or
	( buylargecof [ c , c' ]  && c' . op  =  PUSHLARGECOF)
	or
	( getcof [ c , c' ]  &&  c' . op  =  GETCOF)
	or
	( askchange [ c , c' ]  &&  c' . op = PUSHCHANGE)
	or
	( reset2 [ c , c' ]  &&  c' . op  =  RESET)
	or
	( reset [ c , c' ]  &&  c' . op  =  RESET) )

}

pred  transaction {

	traces  &&
	(CO/ last [ ] ) . op = RESET  &&
	RESET ! in (Cof − CO/ last [ ] ) . op

}

one sig Goal{goals: set CofState}{goals = Coffee}
one sig Subgoals{subgoals: set CofState}{subgoals = Change}

assert  goalsmet  {

	transaction => let m = CO/max [ state . ( Goal . goals ) ] |
	some m=>all sg: Subgoals.subgoals | state.sg in CO/prevs[m]
	
}

// This generates a counterexample with 6
check  goalsmet for 6

\end{verbatim}

\section{E. Coffee machine - multiple coins}
\begin{verbatim}
module  SimpleCofMachine
open  util / ordering [ Cof ]  as  CO
open  util / integer  as  INT
abstract  sig  CofState  {}
one sig Reset, Coin, Coffee, GotCoffee, Change extends CofState {}
abstract  sig  OP  {}
one   sig  ENTER1PCOIN , ENTER2PCOIN , PUSHSMALLCOF , PUSHLARGECOF ,
GETCOF , PUSHCHANGE , RESET extends OP  {}
abstract  sig  CofType  {}
one  sig  SmallCof , LargeCof extends CofType {}

sig  Cof  {

	balance :  one  Int ,
	state :  one  CofState ,
	op :  OP,
	dispenser :  lone  CofType
}

// Give us a quick example

pred  show1 [ c : Cof ]  {}
run show1

pred  enter2pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT / add [ c . balance , int ( 2 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	( c' . state  =  Coin  or  c' . state  =  Reset )
	
}

pred  enter1pcoin [ c , c' : Cof ]  {

	c . state  =  Reset  &&
	c' . balance  =  INT / add [ c . balance , int ( 1 ) ]  &&
	c' . dispenser  =  c . dispenser  &&
	( c' . state  =  Coin  or  c' . state  =  Reset )

}

pred buysmallcof [ c , c' : Cof ]  {

	c . state  =  Coin  &&
	INT / gte [ c . balance , int ( 1 ) ]  &&
	c' . balance  =  INT / sub [ c . balance , int ( 1 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  SmallCof
	c' . state  =  Coffee

}

pred  buylargecof [ c , c' : Cof ]  {
	c . state  =  Coin  &&
	INT / gte [ c . balance , int ( 2 ) ]  &&
	c' . balance  =  INT / sub [ c . balance , int ( 2 ) ]  &&
	no  c . dispenser  &&
	c' . dispenser  =  LargeCof
	c' . state  =  Coffee

}

pred  getcof [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	some  c . dispenser  &&
	no  c' . dispenser  &&
	c' . balance  =  c . balance  &&
	((INT/gte[c.balance, int(0)]=>c'.state=Coin) or c'.state=GotCoffee)
	
}

pred  askchange [ c , c' : Cof ]  {

	c . state  =  GotCoffee
	INT / gt [ c . balance , 0 ]  &&
	INT / zero [ c' . balance ]  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Change

}

pred  reset [ c , c' : Cof ]  {

	c . state  =  Change  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset

}

pred  reset2 [ c , c' : Cof ]  {

	c . state  =  Coffee  &&
	c . balance  =  0  &&
	c' . balance  =  c . balance  &&
	c' . dispenser  =  c . dispenser  &&
	c' . state  =  Reset
	
}

pred  init [ c : Cof ]  {

	c . balance  =  0  &&
	c . state  =  Reset  &&
	c . dispenser  =  none

}

pred  traces  {

	init [CO / first [ ] ]  &&
	all  c : Cof−CO/ last [ ] | let c'  =   CO / next [ c ] |
	( ( enter1pcoin [ c , c' ]  &&  c' . op  =  ENTER1PCOIN)
	or
	( enter2pcoin [ c , c' ]  &&  c' . op  =  ENTER2PCOIN)
	or
	( buysmallcof [ c , c' ]  &&  c' . op  =  PUSHSMALLCOF)
	or
	( buylargecof [ c , c' ]  &&  c' . op  =  PUSHLARGECOF)
	or
	( getcof [ c , c' ]  &&  c' . op  =  GETCOF)
	or
	( askchange [ c , c' ]  &&  c' . op  =  PUSHCHANGE)
	or
	( reset2 [ c , c' ]  &&  c' . op  =  RESET)
	or
	( reset [ c , c' ]  &&  c' . op  =  RESET) )

}

pred  transaction  {

	traces  &&
	(CO / last [ ] ) . op  =  RESET  &&
	RESET ! in (Cof − CO/ last [ ] ) . op
	
}

one sig Goal{goals: set CofState}{goals=Coffee}
one sig Subgoals{subgoals: set CofState}{subgoals=Change}

assert goalsmet {

	transaction /=> let m = CO/max [ state . ( Goal . goals ) ] |
	some m=>all sg: Subgoals.subgoals | state.sg in CO/prevs[m]

}
// This generates a counterexample with 6
check  goalsmet for 7

\end{verbatim}
\end{document}
